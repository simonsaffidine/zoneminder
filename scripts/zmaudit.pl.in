#!/usr/bin/perl -wT
#
# ==========================================================================
#
# ZoneMinder Audit Script, $Date$, $Revision$
# Copyright (C) 2001-2008 Philip Coombes
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# ==========================================================================

use strict;
use bytes;

# ==========================================================================
#
# These are the elements you can edit to suit your installation
#
# ==========================================================================

use constant RECOVER_TAG => '(r)'; # Tag to append to event name when recovered
use constant RECOVER_TEXT => 'Recovered.'; # Text to append to event notes when recovered

# ==========================================================================
#
# You shouldn't need to change anything from here downwards
#
# ==========================================================================

@EXTRA_PERL_LIB@
use ZoneMinder;
use DBI;
use POSIX;
use File::Find;
use Time::HiRes qw/gettimeofday/;
use Getopt::Long;
use autouse 'Pod::Usage'=>qw(pod2usage);

use constant IMAGE_PATH => $Config{ZM_PATH_WEB}.'/'.$Config{ZM_DIR_IMAGES};
use constant EVENT_PATH => ($Config{ZM_DIR_EVENTS}=~m|/|)
                           ? $Config{ZM_DIR_EVENTS}
                           : ($Config{ZM_PATH_WEB}.'/'.$Config{ZM_DIR_EVENTS})
;
use constant ZM_AUDIT_PID => '@ZM_RUNDIR@/zmaudit.pid';


$ENV{PATH}  = '/bin:/usr/bin:/usr/local/bin';
$ENV{SHELL} = '/bin/sh' if exists $ENV{SHELL};
delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};

my $report = 0;
my $interactive = 0;
my $continuous = 0;
my $level = 1;
my $monitor_id = 0;
my $version;
my $force = 0;
my $storage_id = undef;

logInit();

GetOptions(
    continuous     =>\$continuous,
    force          =>\$force,
    interactive    =>\$interactive,
    level          =>\$level,
    'monitor_id=i' =>\$monitor_id,
    report         =>\$report,
    'storage_id=i' =>\$storage_id,
    version        =>\$version
    ) or pod2usage(-exitstatus => -1);

if ( $version ) {
  print( ZoneMinder::Base::ZM_VERSION . "\n");
  exit(0);
}
if ( ($report + $interactive + $continuous) > 1 ) {
  print( STDERR "Error, only one option may be specified\n" );
  pod2usage(-exitstatus => -1);
}

if ( ! exists $Config{ZM_AUDIT_MIN_AGE} ) {
  Fatal('ZM_AUDIT_MIN_AGE is not set in config.');
}

if ( -e ZM_AUDIT_PID ) {
  local $/ = undef;
  open FILE, ZM_AUDIT_PID or die "Couldn't open file: $!";
  binmode FILE;
  my $pid = <FILE>;
  close FILE;
  if ( $force ) {
    Error("zmaudit.pl appears to already be running at pid $pid. Continuing." );
  } else {
    Fatal("zmaudit.pl appears to already be running at pid $pid. If not, please delete " . 
      ZM_AUDIT_PID . " or use the --force command line option." );
  }
} # end if ZM_AUDIT_PID exists

if ( open( my $PID, '>', ZM_AUDIT_PID ) ) {
  print( $PID $$ );
  close( $PID );
} else {
  Error( "Can't open pid file at " . ZM_PID );
}

sub HupHandler {
  Info("Received HUP, reloading");
  &ZoneMinder::Logger::logHupHandler();
}
sub TermHandler {
  Info("Received TERM, exiting");
  Term();
}
sub Term {
  unlink ZM_AUDIT_PID;
  exit( 0 );
}
$SIG{HUP} = \&HupHandler;
$SIG{TERM} = \&TermHandler;
$SIG{INT} = \&TermHandler;

my $dbh = zmDbConnect();

$| = 1;

require ZoneMinder::Monitor;
require ZoneMinder::Storage;
require ZoneMinder::Event;

my $max_image_age = 6/24; # 6 hours
my $max_swap_age = 24/24; # 24 hours
my $image_path = IMAGE_PATH;

my $loop = 1;
my $cleaned = 0;
MAIN: while( $loop ) {

  if ( $continuous ) {
    # if we are running continuously, then just skip to the next
    # interval, otherwise we are a one off run, so wait a second and
    # retry until someone kills us.
    sleep( $Config{ZM_AUDIT_CHECK_INTERVAL} );
  } else {
    sleep 1;
  } # end if

  # After a long sleep, we may need to reconnect to the db
  while ( ! ( $dbh and $dbh->ping() ) ) {
    $dbh = zmDbConnect();
    if ( ! $dbh ) {
      Error('Unable to connect to database');
      if ( $continuous ) {
        # if we are running continuously, then just skip to the next
        # interval, otherwise we are a one off run, so wait a second and
        # retry until someone kills us.
        sleep( $Config{ZM_AUDIT_CHECK_INTERVAL} );
      } else {
        Term();
      } # end if
    } # end if
  } # end while can't connect to the db

  my @Storage_Areas;
  if ( defined $storage_id ) {
    @Storage_Areas = ZoneMinder::Storage->find( Id=>$storage_id );
    if ( !@Storage_Areas ) {
      Error("No Storage Area found with Id $storage_id");
      Term();
    }
    Info("Auditing Storage Area $Storage_Areas[0]{Id} $Storage_Areas[0]{Name} at $Storage_Areas[0]{Path}");
  } elsif ( $Config{ZM_SERVER_ID} ) {
    @Storage_Areas = ZoneMinder::Storage->find( ServerId => $Config{ZM_SERVER_ID} );
    if ( ! @Storage_Areas ) {
      Error("No Storage Area found with ServerId =" . $Config{ZM_SERVER_ID});
      Term();
    }
    Info("Auditing All Storage Areas on Server " . $Storage_Areas[0]->Server()->Name());
  } else {
    @Storage_Areas = ZoneMinder::Storage->find();
    Info("Auditing All Storage Areas");
  }

  my %Monitors;
  my $db_monitors;
  my $monitorSelectSql = $monitor_id ? 'SELECT * FROM Monitors WHERE Id=?' : 'SELECT * FROM Monitors ORDER BY Id';
  my $monitorSelectSth = $dbh->prepare_cached( $monitorSelectSql )
    or Fatal( "Can't prepare '$monitorSelectSql': ".$dbh->errstr() );

  my $eventSelectSql = 'SELECT Id, (unix_timestamp() - unix_timestamp(StartTime)) AS Age
    FROM Events WHERE MonitorId = ?'.(@Storage_Areas ? ' AND StorageId IN ('.join(',',map { '?'} @Storage_Areas).')' : '' ). ' ORDER BY Id';
  my $eventSelectSth = $dbh->prepare_cached( $eventSelectSql )
    or Fatal( "Can't prepare '$eventSelectSql': ".$dbh->errstr() );

  $cleaned = 0;
  my $res = $monitorSelectSth->execute( $monitor_id ? $monitor_id : () )
    or Fatal( "Can't execute: $monitorSelectSql ".$monitorSelectSth->errstr() );
  while( my $monitor = $monitorSelectSth->fetchrow_hashref() ) {
    $Monitors{$$monitor{Id}} = $monitor;

    my $db_events = $db_monitors->{$monitor->{Id}} = {};
    my $res = $eventSelectSth->execute( $monitor->{Id}, map { $$_{Id} } @Storage_Areas )
      or Fatal( "Can't execute: ".$eventSelectSth->errstr() );
    while ( my $event = $eventSelectSth->fetchrow_hashref() ) {
      $db_events->{$event->{Id}} = $event->{Age};
    }
    Debug( 'Got '.int(keys(%$db_events))." events for monitor $monitor->{Id}" );
  } # end while monitors

  my $fs_monitors;

  foreach my $Storage ( @Storage_Areas ) {
    Debug('Checking events in ' . $Storage->Path() );
    if ( ! chdir( $Storage->Path() ) ) {
      Error( 'Unable to change dir to ' . $Storage->Path() );
      next;
    } # end if

    # Please note that this glob will take all files beginning with a digit. 
    foreach my $monitor ( glob('[0-9]*') ) {
      if ( $monitor =~ /\D/ ) {
        Debug("Weird non digit characters in $monitor");
        next;
      }
      if ( $monitor_id and ( $monitor_id != $monitor ) ) {
        Debug("Skipping monitor $monitor because we are only interested in monitor $monitor_id");
        next;
      }

      Debug( "Found filesystem monitor '$monitor'" );
      $fs_monitors->{$monitor} = {} if ! $fs_monitors->{$monitor};
      my $fs_events = $fs_monitors->{$monitor};

      # De-taint
      ( my $monitor_dir ) = ( $monitor =~ /^(.*)$/ );

      {
        my @day_dirs = glob("$monitor_dir/[0-9][0-9]/[0-9][0-9]/[0-9][0-9]");
        Debug(qq`Checking for Deep Events under $$Storage{Path} using glob("$monitor_dir/[0-9][0-9]/[0-9][0-9]/[0-9][0-9]") returned `. scalar @day_dirs . ' events');
        foreach my $day_dir ( @day_dirs ) {
          Debug( "Checking day dir $day_dir" );
          ( $day_dir ) = ( $day_dir =~ /^(.*)$/ ); # De-taint
          if ( ! chdir( $day_dir ) ) {
            Error( "Can't chdir to '$$Storage{Path}/$day_dir': $!" );
            next;
          }
          if ( ! opendir( DIR, '.' ) ) {
            Error( "Can't open directory '$$Storage{Path}/$day_dir': $!" );
            next;
          }
          my @event_links = sort { $b <=> $a } grep { -l $_ } readdir( DIR );
          closedir( DIR );
          my $count = 0;
          foreach my $event_link ( @event_links ) {
            if ( $event_link =~ /[^\d\.]/ ) {
              Warning("Non-event link found $event_link in $day_dir, skipping");
              next;
            }
            Debug( "Checking link $event_link" );
            ( my $event = $event_link ) =~ s/^.*\.//;
            #Event path is hour/minute/sec
            my $event_path = readlink( $event_link );

            if ( !($event_path and -e $event_path) ) {
              aud_print( "Event link $day_dir/$event_link does not point to valid target" );
              if ( confirm() ) {
                ( $event_link ) = ( $event_link =~ /^(.*)$/ ); # De-taint
                unlink( $event_link );
                $cleaned = 1;
              }
            } else {
              Debug( "Checking link $event_link points to $event_path " );
              my $Event = $fs_events->{$event} = new ZoneMinder::Event();
              $$Event{Id} = $event;
              $$Event{Path} = join('/', $Storage->Path(), $day_dir,$event_path);
              $$Event{RelativePath} = join('/', $day_dir,$event_path);
              $$Event{Scheme} = 'Deep';
              $Event->MonitorId( $monitor_dir );
              $Event->StorageId( $Storage->Id() );
              $Event->DiskSpace( undef );
            } # event path exists
          } # end foreach event_link
          chdir( $Storage->Path() );
        } # end foreach day dir
      }

      Debug("Checking for Medium Scheme Events under $$Storage{Path}/$monitor_dir");
      {
        my @event_dirs = glob("$monitor_dir/[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]/*");
        Debug(qq`glob("$monitor_dir/[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]/*") returned ` . scalar @event_dirs . " entries." );
        foreach my $event_dir ( @event_dirs ) {
          if ( ! -d $event_dir ) {
            Debug( "$event_dir is not a dir. Skipping" );
            next;
          }
          my ( $date, $event_id ) = $event_dir =~ /^$monitor_dir\/(\d{4}\-\d{2}\-\d{2})\/(\d+)$/;
          if ( ! $event_id ) {
            Debug("Unable to parse date/event_id from $event_dir");
            next;
          }
          my $Event = $fs_events->{$event_id} = new ZoneMinder::Event();
          $$Event{Id} = $event_id;
          $$Event{Path} = join('/', $Storage->Path(), $event_dir );
          Debug("Have event $$Event{Id} at $$Event{Path}");
          $$Event{Scheme} = 'Medium';
          $$Event{RelativePath} = $event_dir;
          $Event->MonitorId( $monitor_dir );
          $Event->StorageId( $Storage->Id() );
        } # end foreach event
      }

      if ( ! $$Storage{Scheme} ) {
        Debug("Storage Scheme not set on $$Storage{Name}");
        if ( ! chdir( $monitor_dir ) ) {
          Error( "Can't chdir directory '$$Storage{Path}/$monitor_dir': $!" );
          next;
        }
        if ( ! opendir( DIR, "." ) ) {
          Error( "Can't open directory '$$Storage{Path}/$monitor_dir': $!" );
          next;
        }
        my @temp_events = sort { $b <=> $a } grep { -d $_ && $_ =~ /^\d+$/ } readdir( DIR );
        closedir( DIR );
        my $count = 0;
        foreach my $event ( @temp_events ) {
          my $Event = $fs_events->{$event} = new ZoneMinder::Event();
          $$Event{Id} = $event;
          #$$Event{Path} = $event_path;
          $Event->MonitorId( $monitor_dir );
          $Event->StorageId( $Storage->Id() );
        } # end foreach event
        chdir( $Storage->Path() );
      } # if USE_DEEP_STORAGE
      Debug( 'Got '.int(keys(%$fs_events))." filesystem events for monitor $monitor_dir\n" );

      #delete_empty_directories(  $monitor_dir );
    } # end foreach monitor

    if ( $cleaned ) {
      Debug("First stage cleaning done.  Restarting.");
      redo MAIN;
    }

    $cleaned = 0;
    while ( my ( $monitor_id, $fs_events ) = each(%$fs_monitors) ) {
      if ( my $db_events = $db_monitors->{$monitor_id} ) {
        if ( ! $fs_events ) {
          Debug("No fs_events for database monitor $monitor_id");
          next;
        }
        my @event_ids = keys %$fs_events;
        Debug("Have " .scalar @event_ids . " events for monitor $monitor_id");

        foreach my $fs_event_id ( sort { $a <=> $b } keys %$fs_events ) {

          my $Event = $fs_events->{$fs_event_id};

          if ( ! defined( $db_events->{$fs_event_id} ) ) {
            my $age = $Event->age();

            if ( $age > $Config{ZM_AUDIT_MIN_AGE} ) {
              aud_print( "Filesystem event $fs_event_id at $$Event{Path} does not exist in database and is $age seconds old" );
              if ( confirm() ) {
                $Event->delete_files();
                $cleaned = 1;
                delete $fs_events->{$fs_event_id};
              } # end if confirm
            } # end if old enough
          } # end if ! in db events
        } # end foreach fs event
      } else {
        aud_print( "Filesystem monitor '$monitor_id' in $$Storage{Path} does not exist in database" );

        if ( confirm() ) {
          my $command = "rm -rf $monitor_id";
          executeShellCommand( $command );
          $cleaned = 1;
        }
      }
    } # end foreach monitor/filesystem events

    my $monitor_links;
    foreach my $link ( glob('*') ) {
      next if ( !-l $link );
      next if ( -e $link );

      aud_print( "Filesystem monitor link '$link' does not point to valid monitor directory" );
      if ( confirm() ) {
        ( $link ) = ( $link =~ /^(.*)$/ ); # De-taint
        my $command = qq`rm "$link"`;
        executeShellCommand( $command );
        $cleaned = 1;
      }
    }
  } # end foreach Storage Area
  redo MAIN if ( $cleaned );

  $cleaned = 0;
  my $deleteMonitorSql = 'DELETE LOW_PRIORITY FROM Monitors WHERE Id = ?';
  my $deleteMonitorSth = $dbh->prepare_cached( $deleteMonitorSql )
    or Fatal( "Can't prepare '$deleteMonitorSql': ".$dbh->errstr() );
  my $deleteEventSql = 'DELETE LOW_PRIORITY FROM Events WHERE Id = ?';
  my $deleteEventSth = $dbh->prepare_cached( $deleteEventSql )
    or Fatal( "Can't prepare '$deleteEventSql': ".$dbh->errstr() );
  my $deleteFramesSql = 'DELETE LOW_PRIORITY FROM Frames WHERE EventId = ?';
  my $deleteFramesSth = $dbh->prepare_cached( $deleteFramesSql )
    or Fatal( "Can't prepare '$deleteFramesSql': ".$dbh->errstr() );
  my $deleteStatsSql = 'DELETE LOW_PRIORITY FROM Stats WHERE EventId = ?';
  my $deleteStatsSth = $dbh->prepare_cached( $deleteStatsSql )
    or Fatal( "Can't prepare '$deleteStatsSql': ".$dbh->errstr() );

  # Foreach database monitor and it's list of events.
  while ( my ( $db_monitor, $db_events ) = each(%$db_monitors) ) {

    # If we found the monitor in the file system
    if ( my $fs_events = $fs_monitors->{$db_monitor} ) {
      next if ! $db_events;

      while ( my ( $db_event, $age ) = each( %$db_events ) ) {
        if ( ! defined( $fs_events->{$db_event} ) ) {
          my $Event = ZoneMinder::Event->find_one( Id=>$db_event );
          if ( ! $Event ) {
            Debug("Event $db_event is no longer in db.  Filter probably deleted it while we were auditing.");
            next;
          }
          Debug("Event $db_event is not in fs. Should have been at ".$Event->Path());
          if ( ! $Event->StartTime() ) {
            Info("Event $$Event{Id} has no start time.  deleting it.");
            if ( confirm() ) {
              $Event->delete();
              $cleaned = 1;
            }
            next;
          } 
          if ( ! $Event->EndTime() ) {
            if ( $age > $Config{ZM_AUDIT_MIN_AGE} ) {
              Info("Event $$Event{Id} has no end time and is $age seconds old.  deleting it.");
              if ( confirm() ) {
                $Event->delete();
                $cleaned = 1;
              }
              next;
            }
          }
          if ( $Event->check_for_in_filesystem() ) {
            Debug("Database event $$Event{Id} apparently exists at " . $Event->Path() );
          } else {
            if ( $age > $Config{ZM_AUDIT_MIN_AGE} ) {
              aud_print( "Database event '$db_monitor/$db_event' does not exist at " . $Event->Path().' in filesystem, deleting' );
              if ( confirm() ) {
                $Event->delete();
                $cleaned = 1;
              }
            } else {
              aud_print( "Database event '".$Event->Path()." monitor:$db_monitor event:$db_event' does not exist in filesystem but too young to delete age: $age > MIN $Config{ZM_AUDIT_MIN_AGE}.\n" );
            }
          } # end if exists in filesystem
        } # end if ! in fs_events
      } # foreach db_event
      #} else {
      #my $Monitor = new ZoneMinder::Monitor( $db_monitor );
      #my $Storage = $Monitor->Storage();
      #aud_print( "Database monitor '$db_monitor' does not exist in filesystem, should have been at ".$Storage->Path().'/'.$Monitor->Id()."\n" );
#if ( confirm() )
#{
# We don't actually do this in case it's new
#my $res = $deleteMonitorSth->execute( $db_monitor )
#   or Fatal( "Can't execute: ".$deleteMonitorSth->errstr() );
#$cleaned = 1;
#}
    }
  } # end foreach db_monitor
  if ( $cleaned ) {
    Debug("Have done some cleaning, restarting.");
    redo MAIN;
  }

if ( $level > 1 ) {
# Remove orphaned events (with no monitor)
# Shouldn't be possible anymore with FOREIGN KEYS in place
  $cleaned = 0;
  Debug("Checking for Orphaned Events");
  my $selectOrphanedEventsSql = 'SELECT Events.Id, Events.Name
    FROM Events LEFT JOIN Monitors ON (Events.MonitorId = Monitors.Id)
    WHERE isnull(Monitors.Id)';
  my $selectOrphanedEventsSth = $dbh->prepare_cached( $selectOrphanedEventsSql )
    or Error( "Can't prepare '$selectOrphanedEventsSql': ".$dbh->errstr() );
  $res = $selectOrphanedEventsSth->execute()
    or Error( "Can't execute: ".$selectOrphanedEventsSth->errstr() );

  while( my $event = $selectOrphanedEventsSth->fetchrow_hashref() ) {
    aud_print( "Found orphaned event with no monitor '$event->{Id}'" );
    if ( confirm() ) {
      if ( $res = $deleteEventSth->execute( $event->{Id} ) ) {
        $cleaned = 1;
      } else {
        Error( "Can't execute: ".$deleteEventSth->errstr() );
      }
    }
  }
  redo MAIN if $cleaned;
} # end if level > 1

# Remove empty events (with no frames)
  $cleaned = 0;
  Debug("Checking for Events with no Frames");
  my $selectEmptyEventsSql = 'SELECT E.Id AS Id, E.StartTime, F.EventId FROM Events as E LEFT JOIN Frames as F ON (E.Id = F.EventId)
    WHERE isnull(F.EventId) AND now() - interval '.$Config{ZM_AUDIT_MIN_AGE}.' second > E.StartTime';
  if ( my $selectEmptyEventsSth = $dbh->prepare_cached( $selectEmptyEventsSql ) ) {
    if ( $res = $selectEmptyEventsSth->execute() ) {
      while( my $event = $selectEmptyEventsSth->fetchrow_hashref() ) {
        aud_print( "Found empty event with no frame records '$event->{Id}' at $$event{StartTime}" );
        if ( confirm() ) {
          if ( $res = $deleteEventSth->execute( $event->{Id} ) ) {
            $cleaned = 1;
          } else {
            Error( "Can't execute: ".$deleteEventSth->errstr() );
          }
        }
      } # end foreach row
    } else {
      Error( "Can't execute: ".$selectEmptyEventsSth->errstr() );
    }
  } else {
    Error( "Can't prepare '$selectEmptyEventsSql': ".$dbh->errstr() );
  }
  redo MAIN if $cleaned;

# Remove orphaned frame records
  $cleaned = 0;
  Debug("Checking for Orphaned Frames");
  my $selectOrphanedFramesSql = 'SELECT DISTINCT EventId FROM Frames
    WHERE (SELECT COUNT(*) FROM Events WHERE Events.Id=EventId)=0';
  my $selectOrphanedFramesSth = $dbh->prepare_cached( $selectOrphanedFramesSql )
    or Fatal( "Can't prepare '$selectOrphanedFramesSql': ".$dbh->errstr() );
  $res = $selectOrphanedFramesSth->execute()
    or Fatal( "Can't execute: ".$selectOrphanedFramesSth->errstr() );
  while( my $frame = $selectOrphanedFramesSth->fetchrow_hashref() ) {
    aud_print( "Found orphaned frame records for event '$frame->{EventId}'" );
    if ( confirm() ) {
      $res = $deleteFramesSth->execute( $frame->{EventId} )
        or Fatal( "Can't execute: ".$deleteFramesSth->errstr() );
      $cleaned = 1;
    }
  }
  redo MAIN if $cleaned;

if ( $level > 1 ) {
# Remove orphaned stats records
  $cleaned = 0;
  Debug("Checking for Orphaned Stats");
  my $selectOrphanedStatsSql = 'SELECT DISTINCT EventId FROM Stats
    WHERE EventId NOT IN (SELECT Id FROM Events)';
  my $selectOrphanedStatsSth = $dbh->prepare_cached( $selectOrphanedStatsSql )
    or Fatal( "Can't prepare '$selectOrphanedStatsSql': ".$dbh->errstr() );
  $res = $selectOrphanedStatsSth->execute()
    or Fatal( "Can't execute: ".$selectOrphanedStatsSth->errstr() );
  while( my $stat = $selectOrphanedStatsSth->fetchrow_hashref() ) {
    aud_print( "Found orphaned statistic records for event '$stat->{EventId}'" );
    if ( confirm() ) {
      $res = $deleteStatsSth->execute( $stat->{EventId} )
        or Fatal( "Can't execute: ".$deleteStatsSth->errstr() );
      $cleaned = 1;
    }
  }
  redo MAIN if ( $cleaned );
}

# New audit to close any events that were left open for longer than MIN_AGE seconds
  my $selectUnclosedEventsSql =
#"SELECT E.Id, ANY_VALUE(E.MonitorId),
#
#max(F.TimeStamp) as EndTime,
#unix_timestamp(max(F.TimeStamp)) - unix_timestamp(E.StartTime) as Length,
#max(F.FrameId) as Frames,
#count(if(F.Score>0,1,NULL)) as AlarmFrames,
#sum(F.Score) as TotScore,
#max(F.Score) as MaxScore
#FROM Events as E
#INNER JOIN Frames as F on E.Id = F.EventId
#WHERE isnull(E.Frames) or isnull(E.EndTime)
#GROUP BY E.Id HAVING EndTime < (now() - interval ".$Config{ZM_AUDIT_MIN_AGE}.' second)'
#;
    'SELECT *, unix_timestamp(StartTime) AS TimeStamp FROM Events WHERE EndTime IS NULL AND StartTime < (now() - interval '.$Config{ZM_AUDIT_MIN_AGE}.' second)';

  my $selectFrameDataSql = '
SELECT
  max(TimeStamp) as EndTime,
  unix_timestamp(max(TimeStamp)) AS EndTimeStamp,
  max(FrameId) as Frames,
  count(if(Score>0,1,NULL)) as AlarmFrames,
  sum(Score) as TotScore,
  max(Score) as MaxScore
FROM Frames WHERE EventId=?';
  my $selectFrameDataSth = $dbh->prepare_cached($selectFrameDataSql)
    or Fatal( "Can't prepare '$selectFrameDataSql': ".$dbh->errstr() );

  my $selectUnclosedEventsSth = $dbh->prepare_cached( $selectUnclosedEventsSql )
    or Fatal( "Can't prepare '$selectUnclosedEventsSql': ".$dbh->errstr() );
  my $updateUnclosedEventsSql =
    "UPDATE low_priority Events
    SET Name = ?,
        EndTime = ?,
        Length = ?,
        Frames = ?,
        AlarmFrames = ?,
        TotScore = ?,
        AvgScore = ?,
        MaxScore = ?,
        Notes = concat_ws( ' ', Notes, ? )
          WHERE Id = ?"
          ;
  my $updateUnclosedEventsSth = $dbh->prepare_cached( $updateUnclosedEventsSql )
    or Fatal( "Can't prepare '$updateUnclosedEventsSql': ".$dbh->errstr() );
  $res = $selectUnclosedEventsSth->execute()
    or Fatal( "Can't execute: ".$selectUnclosedEventsSth->errstr() );
  while( my $event = $selectUnclosedEventsSth->fetchrow_hashref() ) {
    aud_print( "Found open event '$event->{Id}' at $$event{StartTime}" );
    if ( confirm( 'close', 'closing' ) ) {
      if ( ! ( $res = $selectFrameDataSth->execute($event->{Id}) ) ) {
        Error( "Can't execute: $selectFrameDataSql:".$selectFrameDataSth->errstr() );
        next;
      }
      my $frame = $selectFrameDataSth->fetchrow_hashref();
      if ( $frame ) {
        $res = $updateUnclosedEventsSth->execute(
           sprintf('%s%d%s',
             $Monitors{$event->{MonitorId}}->{EventPrefix},
             $event->{Id},
             RECOVER_TAG
             ),
           $frame->{EndTime},
           $frame->{EndTimeStamp} - $event->{TimeStamp},
           $frame->{Frames},
           $frame->{AlarmFrames},
           $frame->{TotScore},
           $frame->{AlarmFrames}
           ? int($frame->{TotScore} / $frame->{AlarmFrames})
           : 0
           ,
           $frame->{MaxScore},
           RECOVER_TEXT,
           $event->{Id}
          ) or Error( "Can't execute: ".$updateUnclosedEventsSth->errstr() );
      } else {
        Error('SHOULD DELETE');
      } # end if has frame data
    }
  } # end while unclosed event
  Debug("Done closing open events.");

# Now delete any old image files
  if ( my @old_files = grep { -M > $max_image_age } <$image_path/*.{jpg,gif,wbmp}> ) {
    aud_print( 'Deleting '.int(@old_files)." old images\n" );
    my $untainted_old_files = join( ';', @old_files );
    ( $untainted_old_files ) = ( $untainted_old_files =~ /^(.*)$/ );
    unlink( split( /;/, $untainted_old_files ) );
  }

  # Now delete any old swap files
  ( my $swap_image_root ) = ( $Config{ZM_PATH_SWAP} =~ /^(.*)$/ ); # De-taint
  File::Find::find( { wanted=>\&deleteSwapImage, untaint=>1 }, $swap_image_root );

  # Prune the Logs table if required
  if ( $Config{ZM_LOG_DATABASE_LIMIT} ) {
    if ( $Config{ZM_LOG_DATABASE_LIMIT} =~ /^\d+$/ ) {
      # Number of rows
      my $selectLogRowCountSql = 'SELECT count(*) AS Rows FROM Logs';
      my $selectLogRowCountSth = $dbh->prepare_cached( $selectLogRowCountSql )
        or Fatal( "Can't prepare '$selectLogRowCountSql': ".$dbh->errstr() );
      $res = $selectLogRowCountSth->execute()
        or Fatal( "Can't execute: ".$selectLogRowCountSth->errstr() );
      my $row = $selectLogRowCountSth->fetchrow_hashref();
      my $logRows = $row->{Rows};
      if ( $logRows > $Config{ZM_LOG_DATABASE_LIMIT} ) {
        my $deleteLogByRowsSql = 'DELETE low_priority FROM Logs ORDER BY TimeKey ASC LIMIT ?';
        my $deleteLogByRowsSth = $dbh->prepare_cached( $deleteLogByRowsSql )
          or Fatal( "Can't prepare '$deleteLogByRowsSql': ".$dbh->errstr() );
        $res = $deleteLogByRowsSth->execute( $logRows - $Config{ZM_LOG_DATABASE_LIMIT} )
          or Fatal( "Can't execute: ".$deleteLogByRowsSth->errstr() );
        if ( $deleteLogByRowsSth->rows() ) {
          aud_print( 'Deleted '.$deleteLogByRowsSth->rows() ." log table entries by count\n" );
        }
      }
    } else {
      # Time of record
      
      # 7 days is invalid.  We need to remove the s
      if ( $Config{ZM_LOG_DATABASE_LIMIT} =~ /^(.*)s$/ ) {
        $Config{ZM_LOG_DATABASE_LIMIT} = $1;
      }
      my $deleteLogByTimeSql =
      'DELETE low_priority FROM Logs
      WHERE TimeKey < unix_timestamp(now() - interval '.$Config{ZM_LOG_DATABASE_LIMIT}.')';
      my $deleteLogByTimeSth = $dbh->prepare_cached( $deleteLogByTimeSql )
        or Fatal( "Can't prepare '$deleteLogByTimeSql': ".$dbh->errstr() );
      $res = $deleteLogByTimeSth->execute()
        or Fatal( "Can't execute: ".$deleteLogByTimeSth->errstr() );
      if ( $deleteLogByTimeSth->rows() ){
        aud_print( 'Deleted '.$deleteLogByTimeSth->rows()
          ." log table entries by time\n" );
      }
    }
  } # end if ZM_LOG_DATABASE_LIMIT
  $loop = $continuous;

  my $eventcounts_sql = q`
  UPDATE Monitors SET
  TotalEvents=(SELECT COUNT(Id) FROM Events WHERE MonitorId=Monitors.Id),
  TotalEventDiskSpace=(SELECT SUM(DiskSpace) FROM Events WHERE MonitorId=Monitors.Id AND DiskSpace IS NOT NULL),
  ArchivedEvents=(SELECT COUNT(Id) FROM Events WHERE MonitorId=Monitors.Id AND Archived=1),
  ArchivedEventDiskSpace=(SELECT SUM(DiskSpace) FROM Events WHERE MonitorId=Monitors.Id AND Archived=1 AND DiskSpace IS NOT NULL)
  `;

  my $eventcounts_sth = $dbh->prepare_cached( $eventcounts_sql );
  $eventcounts_sth->execute();
  $eventcounts_sth->finish();

  my $eventcounts_hour_sql = q`
  UPDATE Monitors INNER JOIN (
  SELECT  MonitorId, COUNT(*) AS HourEvents, SUM(COALESCE(DiskSpace,0)) AS HourEventDiskSpace
  FROM Events_Hour GROUP BY MonitorId
  ) AS E ON E.MonitorId=Monitors.Id SET
  Monitors.HourEvents = E.HourEvents,
  Monitors.HourEventDiskSpace = E.HourEventDiskSpace
  `;


  my $eventcounts_day_sql = q`
  UPDATE Monitors INNER JOIN (
  SELECT  MonitorId, COUNT(*) AS DayEvents, SUM(COALESCE(DiskSpace,0)) AS DayEventDiskSpace
  FROM Events_Day GROUP BY MonitorId
  ) AS E ON E.MonitorId=Monitors.Id SET
  Monitors.DayEvents = E.DayEvents,
  Monitors.DayEventDiskSpace = E.DayEventDiskSpace
  `;

  my $eventcounts_week_sql = q`
  UPDATE Monitors INNER JOIN (
  SELECT  MonitorId, COUNT(*) AS WeekEvents, SUM(COALESCE(DiskSpace,0)) AS WeekEventDiskSpace
  FROM Events_Week GROUP BY MonitorId
  ) AS E ON E.MonitorId=Monitors.Id SET
  Monitors.WeekEvents = E.WeekEvents,
  Monitors.WeekEventDiskSpace = E.WeekEventDiskSpace
  `;

  my $eventcounts_month_sql = q`
  UPDATE Monitors INNER JOIN (
  SELECT  MonitorId, COUNT(*) AS MonthEvents, SUM(COALESCE(DiskSpace,0)) AS MonthEventDiskSpace
  FROM Events_Month GROUP BY MonitorId
  ) AS E ON E.MonitorId=Monitors.Id SET
  Monitors.MonthEvents = E.MonthEvents,
  Monitors.MonthEventDiskSpace = E.MonthEventDiskSpace
  `;
  my $eventcounts_hour_sth = $dbh->prepare_cached( $eventcounts_hour_sql );
  my $eventcounts_day_sth = $dbh->prepare_cached( $eventcounts_day_sql );
  my $eventcounts_week_sth = $dbh->prepare_cached( $eventcounts_week_sql );
  my $eventcounts_month_sth = $dbh->prepare_cached( $eventcounts_month_sql );
  $eventcounts_hour_sth->execute( ) or Error( "Can't execute: ".$eventcounts_sth->errstr() );
  $eventcounts_day_sth->execute( ) or Error( "Can't execute: ".$eventcounts_sth->errstr() );
  $eventcounts_week_sth->execute( ) or Error( "Can't execute: ".$eventcounts_sth->errstr() );
  $eventcounts_month_sth->execute( ) or Error( "Can't execute: ".$eventcounts_sth->errstr() );
  sleep( $Config{ZM_AUDIT_CHECK_INTERVAL} ) if $continuous;
};

Term();

sub aud_print {
  my $string = shift;
  if ( ! $continuous ) {
    print( $string );
  } else {
    Info( $string );
  }
}

sub confirm {
  my $prompt = shift || 'delete';
  my $action = shift || 'deleting';

  my $yesno = 0;
  if ( $report ) {
    print( "\n" );
  } elsif ( $interactive ) {
    print( ", $prompt Y/n/q: " );
    my $char = <>;
    chomp( $char );
    if ( $char eq 'q' ) {
      exit( 0 );
    }
    if ( !$char ) {
      $char = 'y';
    }
    $yesno = ( $char =~ /[yY]/ );
  } else {
    if ( !$continuous ) {
      print( ", $action\n" );
    } else {
      Info( $action );
    }
    $yesno = 1;
  }
  return( $yesno );
}

sub deleteSwapImage {
  my $file = $_;

  return if $file =~ /^./;

  if ( $file !~ /^zmswap-/ ) {
    Error( "Trying to delete SwapImage that isnt a swap image $file" );
    return;
  }

# Ignore directories
  if ( -d $file ) {
    Error( "Trying to delete a directory instead of a swap image $file" );
    return;
  }

  if ( -M $file > $max_swap_age ) {
    ( $file ) = ( $file =~ /^(.*)$/ );
  
    Debug( "Deleting $file" );
    unlink( $file );
  }
}

sub delete_empty_directories {
  my $DIR;
  Debug("delete_empty_directories $_[0]");
  if ( ! opendir( $DIR, $_[0] ) ) {
    Error( "delete_empty_directories: Can't open directory '".getcwd()."/$_[0]': $!" );
    return;
  }
  my @contents = map { $_ eq '.' or $_ eq '..' ? () : $_ } readdir( $DIR );
  my @dirs = map { -d $_[0].'/'.$_ ? $_ : () } @contents;
  if ( @dirs ) {
    foreach ( @dirs ) {
      delete_empty_directories( $_[0].'/'.$_ );
    }
#Reload, since we may now be empty
    rewinddir $DIR;
    @contents = map { $_ eq '.' or $_ eq '..' ? () : $_ } readdir( $DIR );
  }
  if ( ! @contents ) {
    ( my $dir ) = ( $_[0] =~ /^(.*)$/ );
    unlink $dir;
  } 
  closedir( $DIR );
} # end sub delete_empty_directories

1;
__END__

=head1 NAME

zmaudit.pl - ZoneMinder event file system and database consistency checker

=head1 SYNOPSIS

 zmaudit.pl [-r,-report|-i,-interactive]

=head1 DESCRIPTION

This script checks for consistency between the event filesystem and
the database. If events are found in one and not the other they are
deleted (optionally). Additionally any monitor event directories that
do not correspond to a database monitor are similarly disposed of.
However monitors in the database that don't have a directory are left
alone as this is valid if they are newly created and have no events
yet.

=head1 OPTIONS

 -c, --continuous           - Run continuously
 -f, --force                - Run even if pid file exists
 -i, --interactive          - Ask before applying any changes
 -m, --monitor_id           - Only consider the given monitor
 -r, --report               - Just report don't actually do anything
 -s, --storage_id           - Specify a storage area to audit instead of all
 -v, --version              - Print the installed version of ZoneMinder

=cut
